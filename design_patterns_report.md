# 設計パターン解説レポート

## 1. はじめに

このレポートでは、今回の開発で採用した主要な設計パターンについて、その「考え方」と「実装方法」を解説します。これらのパターンを理解し活用することで、コードの可読性、再利用性、メンテナンス性が向上します。

---

## 2. オブザーバー / イベントエミッター パターン

クラス間の疎結合を実現するために、オブザーバーパターン（イベントエミッターパターンとも呼ばれる）の簡易的な実装を採用しました。

- **考え方**:

  - **観測対象 (Subject / Emitter)**: 状態の変化やイベントを監視されるオブジェクト。今回の`UIManager`がこれにあたります。
  - **観測者 (Observer / Listener)**: 観測対象を監視し、変化の通知を受け取って特定の処理を行うオブジェクト。今回の`GameManager`がこれにあたります。
  - 観測対象は、観測者が誰であるかを具体的に知ることなく、ただ「変化があった」という事実だけを通知します。これにより、両者の独立性が保たれます。

- **実装**:
  1.  **通知用の口を用意 (`UIManager`)**: `this.onStartButtonClick = null;` のように、観測者（`GameManager`）が処理を登録するためのプロパティ（コールバック）を用意します。
  2.  **観測の開始 (`GameManager`)**: `this.uiManager.onStartButtonClick = () => { ... };` のように、観測者（`GameManager`）が観測対象（`UIManager`）のコールバックプロパティに、通知されたときに実行してほしい処理を登録します。
  3.  **イベントの通知 (`UIManager`)**: `UIManager`はボタンが押されたら、コールバックプロパティに関数が登録されているかを確認し、登録されていればそれを実行します。これが「観測者への通知」にあたります。

---

## 3. 依存性の注入 (Dependency Injection)

クラスが必要とする別のクラス（依存オブジェクト）を、自身の内部で生成するのではなく、外部から与えられる設計パターンです。

- **考え方**: `GameManager`は`UIManager`がなければ仕事ができません。しかし、`GameManager`自身が`new UIManager()`とするのではなく、外部（`main.js`）が生成したインスタンスを`constructor`で受け取ります。
- **実装**: `main.js`で `const gameManager = new GameManager(uiManager, sceneManager);` のように、インスタンス化の際に必要な「部品」を引数として注入します。

---

## 4. 継承による抽象化 (Abstraction via Inheritance)

共通の性質を持つ複数のクラスを、一つの「設計図（基底クラス）」としてまとめるパターンです。

- **考え方**: 「平地」「森」「沼」はすべて「マップ」の一種である、という共通の概念を`Map`という基底クラス（抽象クラス）で表現します。
- **実装**:
  1.  **設計図の作成 (`Map`クラス)**: 「マップなら必ず`name`を持つ」といった共通ルールを定義します。
  2.  **製品の作成 (`PlainsMap`など)**: `extends Map`で設計図を継承し、`super()`で具体的な値を設定して「製品」を作ります。
